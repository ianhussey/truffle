---
title: "truffles vignette"
author: "Ian Hussey"
date: today
format:
  html:
    code-fold: show
    highlight-style: haddock
    theme: flatly
    toc: true
    toc-location: left
execute:
  warning: false
  message: false
---

{truffle} is an R package for teaching purposes. It allows you to create datasets with various known effects to be rediscovered (truffles), and then create data processing headaches that have to be solved (dirt). Users must then search for truffles among the dirt. 

Generated datasets can include demographics variables and item-level Likert responses. Known effects (truffles) can be buried in the data including differences in sum-score means between conditions, known correlations between the different outcomes' sum-scores, known Cronbach's alpha values for each scale, etc. Data can also be made messy, contain impossible values, or contain missingness, to create data processing challenges.

The package's functions are currently quite fragile: it is designed for a specific internal use case in our teaching and not (yet) highly flexible, nor does it contain tests or handle errors or make them visible. Currently it can only generate data for a single design: a between groups experiment with equal sample sizes.

## Dependencies

```{r}

#devtools::install_github("ianhussey/truffle")
library(truffle)

# needed by truffle
library(lavaan)
library(dplyr)
library(tidyr)
library(tidyselect)
library(latent2likert)
library(ggplot2)
library(missMethods)

# not needed by truffle but used in this script
library(janitor)
library(readr)
library(knitr)
library(kableExtra)

set.seed(42)

```

## Create truffle

### Generate clean data

- Item level Likert data (no choice)
- Between subjects experiment (control vs intervention) (2 conditions only, but can be renamed)
- Three outcome variables (arbitrary number)
- Known Cronbach's alpha for each scale (arbitrary number)
- Known number of items per scale (arbitrary number)
- Known number of Likert response options (1:k)
- Known correlations between the latent scale scores
- Known APPROXIMATE Cohen's d between the two conditions' latent scale scores (arbitrary number, but recovered value will differ due to reliability, distortion due to converting continuous data to Likert, etc.)

```{r}

dat_truffle <- 
  truffle_likert(study_design = "factorial_between2",
                 n_per_condition = 5,
                 factors  = "X1_latent",
                 prefixes = "X1_item",
                 alpha = .70,
                 n_items = 5,
                 n_levels = 7,
                 approx_d_between_groups = 0.50,
                 seed = 42)

dat_truffle |>
  head(n = 10) |>
  kable() |>
  kable_classic(full_width = FALSE)

```

### Add demographics

```{r}

dat_truffle <- dat_truffle |>
  truffle_demographics() 

dat_truffle |>
  head(n = 10) |>
  kable() |>
  kable_classic(full_width = FALSE)

```

### Calculate sum-scores by scale

```{r}

dat_truffle_sumscores <- dat_truffle |>
  truffle_sum_scores_by_scale() |>
  select(condition, X1_sum) 

dat_truffle_sumscores |>
  head(n = 10) |>
  kable() |>
  kable_classic(full_width = FALSE)

# N, M, SD
dat_truffle_sumscores |>
  pivot_longer(cols = starts_with("X"),
               names_to = "scale",
               values_to = "sum_score") |>
  group_by(scale, condition) |>
  summarize(n = n(),
            mean = mean(sum_score, na.rm = TRUE),
            sd = sd(sum_score, na.rm = TRUE)) |>
  mutate_if(is.numeric, round_half_up, digits = 2)

```

### Check generated data

Check that the sum scores conform to the predefined properties and that the item level data is approximately normal.

```{r}
#| fig-height: 6
#| fig-width: 10

truffle_check(dat_truffle)

```

## Add dirt

Generate data for the same study but add dirt, step by step.

### Demographics

```{r}

dat_truffle_and_dirt <- 
  truffle_likert(n_per_condition = 5,
                 factors  = "X1_latent",
                 prefixes = "X1_item",
                 alpha = .70,
                 n_items = 5,
                 n_levels = 7,
                 approx_d_between_groups = 0.50,
                 seed = 42) |>
  dirt_demographics() 

dat_truffle_and_dirt |>
  head(n = 10) |>
  kable() |>
  kable_classic(full_width = FALSE)

```

### Impossible values ('outliers')

```{r}

dat_truffle_and_dirt <- dat_truffle_and_dirt |>
  dirt_impossible_values(prop = .04, replacement_value = 8)

dat_truffle_and_dirt |>
  head(n = 10) |>
  kable() |>
  kable_classic(full_width = FALSE)

```

### Number formatting 

First generate reaction time data

```{r}

dat_truffle_and_dirt <- dat_truffle_and_dirt |>
  mutate(completion_time = truffle_reaction_times(n = n()))

ggplot(dat_truffle_and_dirt, aes(completion_time)) +
  geom_histogram()

```

Add dirt to the formatting of the reaction times: comma thousands separators and the "ms" suffix.

```{r}

dat_truffle_and_dirt <- dat_truffle_and_dirt |>
 dirt_numbers(cols = "completion_time")

dat_truffle_and_dirt |>
  head(n = 10) |>
  kable() |>
  kable_classic(full_width = FALSE)

```

### Dates

```{r}

dat_truffle_and_dirt <- dat_truffle_and_dirt |>
  dirt_dates(col = "date")

dat_truffle_and_dirt |>
  head(n = 10) |>
  kable() |>
  kable_classic(full_width = FALSE)

```

### Missingness

MCAR missingness

```{r}

dat_truffle_and_dirt_temp <- dat_truffle_and_dirt |>
  dirt_missingness(prop = .05, dirtier = FALSE) 

dat_truffle_and_dirt_temp |>
  head(n = 10) |>
  kable() |>
  kable_classic(full_width = FALSE)

```

MCAR missingness + inconsistent missingness labels

```{r}

dat_truffle_and_dirt <- dat_truffle_and_dirt |>
  dirt_missingness(prop = .05, dirtier = TRUE)

dat_truffle_and_dirt |>
  head(n = 10) |>
  kable() |>
  kable_classic(full_width = FALSE)

```

### Untidy columns

With more than one data point per cell, ie both block and trial number, violating Tidy Data principles.

```{r}

dat_truffle_and_dirt <- dat_truffle_and_dirt |>
  dirt_untidy(col = "block_trial")

dat_truffle_and_dirt |>
  head(n = 10) |>
  kable() |>
  kable_classic(full_width = FALSE)

```

### Duplicate rows

```{r}

dat_truffle_and_dirt <- dat_truffle_and_dirt |>
  dirt_duplicates(prop = 0.05)

dat_truffle_and_dirt |>
  head(n = 10) |>
  kable() |>
  kable_classic(full_width = FALSE)

```

### Colnames

```{r}

# move some columns around before renaming makes it hard
dat_truffle_and_dirt <- dat_truffle_and_dirt |>
  relocate(date, .after = "id") |>
  relocate(completion_time, .after = "id") |>
  relocate(block_trial, .after = "id") |>
  write_lines("dat_truffle_and_dirt.csv")

dat_truffle_and_dirt <- dat_truffle_and_dirt |>
  dirt_colnames()

dat_truffle_and_dirt |>
  head(n = 10) |>
  kable() |>
  kable_classic(full_width = FALSE)

```

### Headers

```{r}

dat_truffle_and_dirt_with_header <- dat_truffle_and_dirt |>
  dirt_header_rows()

dat_truffle_and_dirt_with_header |>
  head(n = 10) |>
  kable() |>
  kable_classic(full_width = FALSE)

# write to desk
dat_truffle_and_dirt_with_header |>
  readr::write_lines("dat_truffle_and_dirt_with_header.csv")

# re-import later
dirty <- readr::read_csv("dat_truffle_and_dirt_with_header.csv")

dirty |>
  head(n = 10) |>
  kable() |>
  kable_classic(full_width = FALSE)

clean <- readr::read_csv("dat_truffle_and_dirt_with_header.csv", skip = 2)

clean |>
  head(n = 10) |>
  kable() |>
  kable_classic(full_width = FALSE)

```

## Snuffle functions to help you find truffles 

`snuffle_` functions are designed to help the user find truffles (underlying effects) among the dirt (data processing issues). 

### Sum scores

Calculating sum scores is an extremely common task, and yet there are a surprising number of ways to mess it up given impossible scores in the dataset, missingness, and reversed items. 

`snuffle_sum_scores()` calculates sum scores, imputing missing values from each participant's mean. There are, of course, much better and more sophisticated ways to deal with item missingness, but this is probably the most common way - so much so that it's often not even reported in articles. The function also excludes data that are beyond the scale's response bounds (ie impossible values), and returns diagnostics on the number of missing items, which items were missing, the number of impossible values and which were missing. It can also reverse score a vector of specified items. 

Which items are used in the sum scoring can be specified in a number of ways, e.g., `select()`ing the items earlier in the chunk, or using a common naming prefix to select them (e.g., starting with "X1_"), or even a more sophisticated regex call to find the desired columns. 

```{r}

dat_truffle_and_dirt <- 
  truffle_likert(study_design = "factorial_between2",
                 n_per_condition = 10,
                 factors  = "X1_latent",
                 prefixes = "X1_item",
                 alpha = .70,
                 n_items = 5,
                 n_levels = 7,
                 approx_d_between_groups = 0.50,
                 seed = 42) |>
  truffle_demographics() |>
  dirt_missingness(prop = .10, dirtier = FALSE) |>
  dirt_impossible_values(prop = .04, replacement_value = 8)

dat_truffle_and_dirt_snuffled <- dat_truffle_and_dirt |>
  snuffle_sum_scores("X1_", 
                     min = 1, 
                     max = 7, 
                     id_col = "id")

dat_truffle_and_dirt_snuffled |>
  head(n = 20) |>
  kable() |>
  kable_classic(full_width = FALSE)

```

```{r}
#| eval: false
#| include: false

md_table <- dat_truffle_and_dirt_snuffled |>
  head(n = 20) |>
  kable(format = "markdown") 

cat(md_table)

```

## More complicated truffles 

### Multiple correlated outcomes with more dirt

```{r}
#| fig-height: 20
#| fig-width: 20

dat_truffle_complex <-
  truffle_likert(n_per_condition = 200,
                 factors  = c("X1_latent", "X2_latent", "X3_latent"),
                 prefixes = c("X1_item", "X2_item", "X3_item"),
                 alpha = c(.70, .75, .80),
                 n_items = c(10, 7, 15),
                 n_levels = 7,
                 r_among_outcomes = 0.50,
                 approx_d_between_groups = c(0.50, 0.20, 1.00),
                 seed = 42)

# # for readme
# dat_truffle_complex <-
#   truffle_likert(n_per_condition = 5,
#                  factors  = "X1_latent",
#                  prefixes = "X1_item",
#                  alpha = .70,
#                  n_items = 5,
#                  n_levels = 7,
#                  approx_d_between_groups = 0.50,
#                  seed = 42)

dat_truffle_complex |>
  truffle_check()

dat_truffle_and_dirt_complex <- dat_truffle_complex |>
  dirt_demographics() |>
  dirt_impossible_values(prop = .04, replacement_value = 8) |>
  # generate RT data and then add dirt
  mutate(completion_time = truffle_reaction_times(n = n())) |>
  dirt_numbers(cols = "completion_time") |>
  dirt_dates(col = "date") |>
  dirt_missingness(prop = .05) |>
  dirt_untidy(col = "block_trial") |>
  dirt_duplicates(prop = 0.05) |>
  # move some columns around before renaming makes it hard
  relocate(date, .after = "id") |>
  relocate(completion_time, .after = "id") |>
  relocate(block_trial, .after = "id") |>
  dirt_colnames() |>
  dirt_header_rows()

dat_truffle_and_dirt_complex |>
  readr::write_lines("dat_truffle_and_dirt_complex.csv")

dat_truffle_and_dirt_complex |>
  head(n = 10) |>
  kable() |>
  kable_classic(full_width = FALSE)

```

### Cross-sectional data

```{r}

R <- matrix(c( 1, .1, .3,
              .1,  1, .5,
              .3, .5,  1), 
            3, 3, byrow = TRUE)

dat_truffle <- 
  truffle_likert(study_design = "crosssectional",
                 n_per_condition = 1000,
                 factors  = c("X1_latent", "X2_latent", "X3_latent"),
                 prefixes = c("X1_item", "X2_item", "X3_item"),
                 alpha = c(.90, .90, .70),
                 n_items = c(10, 7, 15),
                 r_among_outcomes = R,
                 n_levels = c(10, 7, 7),
                 seed = 42) |>
  snuffle_sum_scores("X1_", 
                     min = 1, 
                     max = 10, 
                     id_col = "id") |>
  snuffle_sum_scores("X2_", 
                     min = 1, 
                     max = 7, 
                     id_col = "id") |>
  snuffle_sum_scores("X3_", 
                     min = 1, 
                     max = 7, 
                     id_col = "id")

dat_truffle |>
  select(X1_sumscore, X2_sumscore, X3_sumscore) |>
  cor()

```






