% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/truffle_likert.R
\name{truffle_likert}
\alias{truffle_likert}
\title{Generate Likert-Scale Data for Two Conditions (with latent mean shifts)}
\usage{
truffle_likert(
  study_design = "factorial_between2",
  n_per_condition = 100,
  factors = NULL,
  prefixes = NULL,
  alpha = 0.7,
  n_items,
  n_levels = 7,
  r_among_outcomes = 0.3,
  approx_d_between_groups = 0.5,
  condition_names = c("control", "treatment"),
  seed = NULL,
  lv_var = 1,
  x_var = 1,
  return_continuous = FALSE
)
}
\arguments{
\item{study_design}{Character scalar. Currently only \code{"factorial_between2"}
is supported (two independent groups). Default \code{"factorial_between2"}.}

\item{n_per_condition}{Integer. Number of participants per group (default \code{100}).}

\item{factors}{Character vector (length \eqn{K}). Latent factor names. If \code{NULL},
defaults to \code{X1_latent}, \code{X2_latent}, \dots.}

\item{prefixes}{Character vector (length \eqn{K}). Item name prefixes per factor.
If \code{NULL}, defaults to \code{X1_item}, \code{X2_item}, \dots.}

\item{alpha}{Numeric scalar or length-\eqn{K} vector. Target Cronbach's alpha
for each factor (default \code{0.70}). Scalars are recycled.}

\item{n_items}{Integer vector (length \eqn{K}). Number of items per factor (each \eqn{\ge} 2).}

\item{n_levels}{Integer. Number of Likert response categories (default \code{7}).}

\item{r_among_outcomes}{Either a single latent correlation in \eqn{(-1,1)} applied to
all pairs, or a \eqn{K \times K} latent correlation matrix (symmetric, unit diagonal).}

\item{approx_d_between_groups}{Numeric. Either a single Cohen's \emph{d} applied to
\emph{all} latents, or a length-\eqn{K} vector (optionally \emph{named} by \code{factors})
giving per-latent \emph{d} values. Scalars are recycled; named vectors are
matched to \code{factors}.}

\item{condition_names}{Character length-2 vector giving group labels
(default \code{c("control","treatment")}).}

\item{seed}{Optional integer seed for reproducibility.}

\item{lv_var}{Numeric scalar or length-\eqn{K} vector of latent variances (default \code{1}).}

\item{x_var}{Numeric scalar or length-\eqn{K} vector of item variances (default \code{1}).}

\item{return_continuous}{Logical. If \code{TRUE}, return a list including the
continuous simulated data and model strings in addition to the Likert data.}
}
\value{
If \code{return_continuous = FALSE} (default): a data frame with columns
\itemize{
\item \code{id} — participant ID (integer sequence)
\item \code{condition} — group label (\code{condition_names})
\item item responses — Likert-scale items named \code{<prefix><index>}
}
If \code{return_continuous = TRUE}: a list with elements
\itemize{
\item \code{dat_lik} — Likert data frame as above
\item \code{dat_ctrl_cont}, \code{dat_treat_cont} — continuous data per group
\item \code{item_cols} — character vector of item column names
\item \code{models} — list with \code{base}, \code{ctrl}, \code{treat} lavaan syntax
\item \code{d_per_factor} — the per-latent \emph{d} vector actually used
}
}
\description{
Simulate item-level Likert data for two groups (e.g., control vs. treatment)
by (i) specifying a multi-factor latent variable model, (ii) shifting latent
means by a specified Cohen's \emph{d} in the treatment group, and
(iii) discretizing continuous indicators to Likert categories using shared
cutpoints across groups (to preserve mean differences).
}
\details{
The base measurement model and latent covariance structure are produced by
the internal helper \code{.make_lavaan_kfactor_corr()}, which converts
alphas into tau-equivalent loadings and sets residual variances so that
item variances equal \code{x_var}. Latent means are fixed at 0 in the control
group and shifted by \code{approx_d_between_groups} in the treatment group
(on the latent scale; when \code{lv_var = 1}, the shift equals Cohen's \emph{d}).

Continuous indicators are simulated via \code{lavaan::simulateData()} and
discretized to Likert scores using shared cutpoints (fixed reference
\eqn{\mu=0}, \eqn{\sigma=1}) across groups. This avoids washing out the
treatment mean shift that would occur if cutpoints were fit per group/column.
}
\examples{
\dontrun{
# Three-factor example with a common d applied to all latents
dat <- truffle_likert(
  study_design = "factorial_between2",
  n_items     = c(5, 6, 7),
  alpha       = c(.70, .75, .80),
  factors     = c("X1_latent","X2_latent","X3_latent"),
  prefixes    = c("X1_item","X2_item","X3_item"),
  r_among_outcomes = 0.3,
  approx_d_between_groups = 0.5,
  n_per_condition = 300,
  n_levels    = 5,
  seed = 123
)

# Per-latent d's (named vector, order-independent)
dat2 <- truffle_likert(
  n_items   = c(5, 6, 7),
  alpha     = .75,
  approx_d_between_groups = c(X2_latent = 0.2, X1_latent = 0.5, X3_latent = 0.1),
  seed = 42
)
}

}
\seealso{
\code{\link[lavaan]{simulateData}}
}
